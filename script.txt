# whoami

My name is Lucas, I am currently a Software Engineer at Gebit.
My carreer is mostly working as a Fullstack, although right now I am a developer working on the self checkout from Aldi.
On my free time I like to experiment with all sorts of things.
You can look for me as Beothorn, it is my handle at github, and many other places and as far as I know, 
no one uses this handle so if you find it pretty certain that that's me.

# What this is about

I will be presenting today Javaflame, a very simple debugging tool.  
It works by instrumenting bytecode so although it is written with Java as a target, it should also work other JVM languages like scala and kotlin.  
I hope today I can show how can you use this tool to understand better what is happening inside your code or maybe inspire you to write your own solution.

# First, the problem

When you are presented with a bug or a new feature that you need to implement, or when you start working on a new project, I think everyone comes up with the same question.
Which is, what is going on here?
Yes, you have an idea in theory what should be happening, and why (hopefully), but the truth is that usually there is so much happening, 
and so much missing context that it is hard to get a big picture.
I think everyone has been in this situation, I know I did, and there are many ways to try to begin figuring it all out.

Some of those are just plain old print on the console, which gives a good idea if the code is even executed and with what values.
Or, a little bit more advanced just adding a lot of breakpoints. This is better than printing on the console as, in this case, you can see 
the call stack and you can also control the flow so you can see what is happening.
Those are valid ways to do it, but there are some minor issues with each approach.

# Printing on the console

We should not underestimate printing on the console. It is flexible, it works without the need of any other tool and 
it gives a good context about the time when certain events happen.
But, there are some problems. First is that you need to change the code to add the output.
That means you need to go through whatever compile/run cycle your application needs to run and also that 
you should not forget to delete your debugging code later.
When there is already a lot of logs, either added by you or not, it starts to become hard to see your entry among 
all other entries on your log. 
Sometimes it is like looking for a drop in the ocean. Without a very good filtering tool it can be 
very slow to figure what happened, specially if the logs keep rolling non-stop.
And the price to pay for flexibility is that it can become a little confusing to read the output, 
specially if it is big or if it is some kind of composition.  

# Breakpoints

Breakpoints are great because they give you context.
But the context they give you is, obviously, from the point of the execution where you are right now.
It is possible to move down the stack and get information, but this is limited to the current function call.  
Moving on in time is slow. You can't have context about execution that already happened and to get future context 
you either know exactly where to stop, on which case you add a breakpoint, or you move step by step, analyzing what happens.
Well, debugging step by step can be slow if what you wnat to get is the big picture, so maybe there is a better way?

# Mission control, observability or profilers

Well, there is. If you could record the execution and find a nice way to visualize it this would already solve your issue.  
And there are ways to have something like this.  
First, let me show a flamegraph. I think this must be familiar to many already, but if not this is what it looks like.
You get the function calls bottom up, where each row is a subsequent function call. So, every call above was originated from the one below.
Time is the x axis, so you can have a very good idea of what is calling what and when.  
You can also see how long a function call take in relation to the other function calls, but for understanding what 
is going on, only the relation and order between calls is important.

And, actually, there are already lots of tools that do that. Observability tools like datadog or almost any tool to measure performance has this view.
Here for example you can see a flamegraph generated by the JDK mission control from oracle.  
There is only one issue. All we get here is the function calls.
And, well, there is a reason for that.
When you want to get a history of the execution stack a good way to get i is by sampling.

This is a very smart strategy as it is light, you don't have to keep any state so it is cheap regarding memory and you can even tweak the sampling interval,
as long as you keep in mind that bigger sampling intervals would give you less precision.
So if you want a version that keeps argument values , this would cost memory, obviously, but also cpu, to get the string representation of the value.
And that's why...

# Why/Where to use it

This is not something to run on production. It is something to maybe run on your test environment, but, the actual idea behind it is to run it on your own setup.  
Javaflame is an agent that does not require any server, or another process running on parallel or even configuration files.
It is designed to get all required values from the command line and output an html file with the collected data.

# Java agent

Javaflame does not work by sampling the stack. Instead it changes the bytecode of the functions to call code that puts the calls on a separate stack and stores the values of all parameters.  
Internally it is using a library called byte buddy. It is a very nice library that gives you a fluent interface to manipulate bytecode.  
In fact, although javaflame is a general solution that is easy to use, coming up with something more specialized is trivial.  

<Byte buddy simple example here>

# To get the big picture Javaflame

Does not require code changes
Works locally and offline
Captures all argument values
Not only for my own code
See them all together in a single place
Does not care about performance

# To use it

<show github page>
Download the agent (check the jar size :)
Add to the JVM command line:
<Show fisrt example>

<Show fizzbuzz>
Play around, show buttons, click on them
Mention it is a canvas, save the image
<Show unit test>
<Show multithread>
<Show  search feature, show filter>
Explain search shows the reverse hierarchy. explain what filter does.  

<Show Cake factory Demo>

Show that there is a lot going on, unrelated to the actual system

Too much data - Filter expressions
